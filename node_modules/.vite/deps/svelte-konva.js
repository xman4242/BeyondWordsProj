import {
  require_lib
} from "./chunk-BUWCLTOY.js";
import "./chunk-W54PNBU6.js";
import "./chunk-X7HCJ7ZS.js";
import {
  writable
} from "./chunk-VX7U7QN4.js";
import {
  SvelteComponentDev,
  add_location,
  assign,
  binding_callbacks,
  check_outros,
  children,
  claim_element,
  component_subscribe,
  compute_rest_props,
  createEventDispatcher,
  create_slot,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  exclude_internal_props,
  getContext,
  get_all_dirty_from_scope,
  get_slot_changes,
  get_spread_update,
  group_outros,
  init,
  insert_hydration_dev,
  noop,
  onDestroy,
  onMount,
  safe_not_equal,
  setContext,
  set_attributes,
  transition_in,
  transition_out,
  update_slot_base,
  validate_slots,
  validate_store
} from "./chunk-DV54KGQ5.js";
import "./chunk-2AFTNLNW.js";
import {
  __toESM
} from "./chunk-TCQZMY3T.js";

// node_modules/svelte-konva/dist/Arc.svelte
var import_konva = __toESM(require_lib());

// node_modules/svelte-konva/dist/util/events.js
var KONVA_EVENTS = [
  "mouseover",
  "mouseout",
  "mouseenter",
  "mouseleave",
  "mousemove",
  "mousedown",
  "mouseup",
  "wheel",
  "click",
  "dblclick",
  "touchstart",
  "touchmove",
  "touchend",
  "tap",
  "dbltap",
  "pointerdown",
  "pointermove",
  "pointerup",
  "pointercancel",
  "pointerover",
  "pointerenter",
  "pointerout",
  "pointerleave",
  "pointerclick",
  "pointerdblclick",
  "dragstart",
  "dragmove",
  "dragend",
  "transformstart",
  "transform",
  "transformend"
];
function registerEvents(dispatch, node) {
  KONVA_EVENTS.forEach((event) => {
    node.on(event, (payload) => {
      if (!dispatch(event, payload, { cancelable: true })) {
        payload.cancelBubble = true;
      }
    });
  });
}

// node_modules/svelte-konva/dist/util/manageContext.js
var CONTAINER_COMPONENT_KEYS = [
  "svelte-konva-stage",
  "svelte-konva-layer",
  "svelte-konva-group",
  "svelte-konva-label"
];
var Container;
(function(Container2) {
  Container2[Container2["Stage"] = 0] = "Stage";
  Container2[Container2["Layer"] = 1] = "Layer";
  Container2[Container2["Group"] = 2] = "Group";
  Container2[Container2["Label"] = 3] = "Label";
})(Container || (Container = {}));
var CONTAINER_ERROR = "svelte-konva: Component does not have any parent container. Please make sure that the component is wrapped inside a Layer or Group.";
var LAYER_ERROR = "svelte-konva: A Layer needs to have a Stage as parent.";
function setContainerContext(kind, value) {
  CONTAINER_COMPONENT_KEYS.forEach((key) => {
    setContext(key, null);
  });
  setContext(CONTAINER_COMPONENT_KEYS[kind], value);
}
function getParentContainer() {
  for (let i = 1; i < 4; i++) {
    const parent = getContext(CONTAINER_COMPONENT_KEYS[i]);
    if (parent) {
      return parent;
    }
  }
  throw new Error(CONTAINER_ERROR);
}
function getParentStage() {
  const parent = getContext(CONTAINER_COMPONENT_KEYS[Container.Stage]);
  if (parent) {
    return parent;
  }
  throw new Error(LAYER_ERROR);
}

// node_modules/svelte-konva/dist/util/object.js
function copyExistingKeys(target, source) {
  for (const key in target) {
    if (Object.prototype.hasOwnProperty.call(source, key)) {
      target[key] = source[key];
    }
  }
}

// node_modules/svelte-konva/dist/Arc.svelte
function create_fragment(ctx) {
  const block = {
    c: noop,
    l: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let $parent;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Arc", slots, []);
  let { config } = $$props;
  let { handle = new import_konva.default.Arc(config) } = $$props;
  let { staticConfig = false } = $$props;
  let parent = getParentContainer();
  validate_store(parent, "parent");
  component_subscribe($$self, parent, (value) => $$invalidate(4, $parent = value));
  let dispatcher = createEventDispatcher();
  onMount(() => {
    $parent.add(handle);
    if (!staticConfig) {
      handle.on("transformend", () => {
        copyExistingKeys(config, handle.getAttrs());
        $$invalidate(1, config);
      });
      handle.on("dragend", () => {
        copyExistingKeys(config, handle.getAttrs());
        $$invalidate(1, config);
      });
    }
    registerEvents(dispatcher, handle);
  });
  onDestroy(() => {
    handle.destroy();
  });
  $$self.$$.on_mount.push(function() {
    if (config === void 0 && !("config" in $$props || $$self.$$.bound[$$self.$$.props["config"]])) {
      console.warn("<Arc> was created without expected prop 'config'");
    }
  });
  const writable_props = ["config", "handle", "staticConfig"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Arc> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("config" in $$props2)
      $$invalidate(1, config = $$props2.config);
    if ("handle" in $$props2)
      $$invalidate(2, handle = $$props2.handle);
    if ("staticConfig" in $$props2)
      $$invalidate(3, staticConfig = $$props2.staticConfig);
  };
  $$self.$capture_state = () => ({
    Konva: import_konva.default,
    onMount,
    onDestroy,
    createEventDispatcher,
    registerEvents,
    getParentContainer,
    copyExistingKeys,
    config,
    handle,
    staticConfig,
    parent,
    dispatcher,
    $parent
  });
  $$self.$inject_state = ($$props2) => {
    if ("config" in $$props2)
      $$invalidate(1, config = $$props2.config);
    if ("handle" in $$props2)
      $$invalidate(2, handle = $$props2.handle);
    if ("staticConfig" in $$props2)
      $$invalidate(3, staticConfig = $$props2.staticConfig);
    if ("parent" in $$props2)
      $$invalidate(0, parent = $$props2.parent);
    if ("dispatcher" in $$props2)
      dispatcher = $$props2.dispatcher;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*handle, config*/
    6) {
      $:
        handle.setAttrs(config);
    }
  };
  return [parent, config, handle, staticConfig];
}
var Arc = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, { config: 1, handle: 2, staticConfig: 3 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Arc",
      options,
      id: create_fragment.name
    });
  }
  get config() {
    throw new Error("<Arc>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set config(value) {
    throw new Error("<Arc>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get handle() {
    throw new Error("<Arc>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set handle(value) {
    throw new Error("<Arc>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get staticConfig() {
    throw new Error("<Arc>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set staticConfig(value) {
    throw new Error("<Arc>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Arc_default = Arc;

// node_modules/svelte-konva/dist/Arrow.svelte
var import_konva2 = __toESM(require_lib());
function create_fragment2(ctx) {
  const block = {
    c: noop,
    l: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let $parent;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Arrow", slots, []);
  let { config } = $$props;
  let { handle = new import_konva2.default.Arrow(config) } = $$props;
  let { staticConfig = false } = $$props;
  let parent = getParentContainer();
  validate_store(parent, "parent");
  component_subscribe($$self, parent, (value) => $$invalidate(4, $parent = value));
  let dispatcher = createEventDispatcher();
  onMount(() => {
    $parent.add(handle);
    if (!staticConfig) {
      handle.on("transformend", () => {
        copyExistingKeys(config, handle.getAttrs());
        $$invalidate(1, config);
      });
      handle.on("dragend", () => {
        copyExistingKeys(config, handle.getAttrs());
        $$invalidate(1, config);
      });
    }
    registerEvents(dispatcher, handle);
  });
  onDestroy(() => {
    handle.destroy();
  });
  $$self.$$.on_mount.push(function() {
    if (config === void 0 && !("config" in $$props || $$self.$$.bound[$$self.$$.props["config"]])) {
      console.warn("<Arrow> was created without expected prop 'config'");
    }
  });
  const writable_props = ["config", "handle", "staticConfig"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Arrow> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("config" in $$props2)
      $$invalidate(1, config = $$props2.config);
    if ("handle" in $$props2)
      $$invalidate(2, handle = $$props2.handle);
    if ("staticConfig" in $$props2)
      $$invalidate(3, staticConfig = $$props2.staticConfig);
  };
  $$self.$capture_state = () => ({
    Konva: import_konva2.default,
    onMount,
    onDestroy,
    createEventDispatcher,
    registerEvents,
    getParentContainer,
    copyExistingKeys,
    config,
    handle,
    staticConfig,
    parent,
    dispatcher,
    $parent
  });
  $$self.$inject_state = ($$props2) => {
    if ("config" in $$props2)
      $$invalidate(1, config = $$props2.config);
    if ("handle" in $$props2)
      $$invalidate(2, handle = $$props2.handle);
    if ("staticConfig" in $$props2)
      $$invalidate(3, staticConfig = $$props2.staticConfig);
    if ("parent" in $$props2)
      $$invalidate(0, parent = $$props2.parent);
    if ("dispatcher" in $$props2)
      dispatcher = $$props2.dispatcher;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*handle, config*/
    6) {
      $:
        handle.setAttrs(config);
    }
  };
  return [parent, config, handle, staticConfig];
}
var Arrow = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, { config: 1, handle: 2, staticConfig: 3 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Arrow",
      options,
      id: create_fragment2.name
    });
  }
  get config() {
    throw new Error("<Arrow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set config(value) {
    throw new Error("<Arrow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get handle() {
    throw new Error("<Arrow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set handle(value) {
    throw new Error("<Arrow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get staticConfig() {
    throw new Error("<Arrow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set staticConfig(value) {
    throw new Error("<Arrow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Arrow_default = Arrow;

// node_modules/svelte-konva/dist/Circle.svelte
var import_konva3 = __toESM(require_lib());
function create_fragment3(ctx) {
  const block = {
    c: noop,
    l: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  let $parent;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Circle", slots, []);
  let { config } = $$props;
  let { handle = new import_konva3.default.Circle(config) } = $$props;
  let { staticConfig = false } = $$props;
  let parent = getParentContainer();
  validate_store(parent, "parent");
  component_subscribe($$self, parent, (value) => $$invalidate(4, $parent = value));
  let dispatcher = createEventDispatcher();
  onMount(() => {
    $parent.add(handle);
    if (!staticConfig) {
      handle.on("transformend", () => {
        copyExistingKeys(config, handle.getAttrs());
        $$invalidate(1, config);
      });
      handle.on("dragend", () => {
        copyExistingKeys(config, handle.getAttrs());
        $$invalidate(1, config);
      });
    }
    registerEvents(dispatcher, handle);
  });
  onDestroy(() => {
    handle.destroy();
  });
  $$self.$$.on_mount.push(function() {
    if (config === void 0 && !("config" in $$props || $$self.$$.bound[$$self.$$.props["config"]])) {
      console.warn("<Circle> was created without expected prop 'config'");
    }
  });
  const writable_props = ["config", "handle", "staticConfig"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Circle> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("config" in $$props2)
      $$invalidate(1, config = $$props2.config);
    if ("handle" in $$props2)
      $$invalidate(2, handle = $$props2.handle);
    if ("staticConfig" in $$props2)
      $$invalidate(3, staticConfig = $$props2.staticConfig);
  };
  $$self.$capture_state = () => ({
    Konva: import_konva3.default,
    onMount,
    onDestroy,
    createEventDispatcher,
    registerEvents,
    getParentContainer,
    copyExistingKeys,
    config,
    handle,
    staticConfig,
    parent,
    dispatcher,
    $parent
  });
  $$self.$inject_state = ($$props2) => {
    if ("config" in $$props2)
      $$invalidate(1, config = $$props2.config);
    if ("handle" in $$props2)
      $$invalidate(2, handle = $$props2.handle);
    if ("staticConfig" in $$props2)
      $$invalidate(3, staticConfig = $$props2.staticConfig);
    if ("parent" in $$props2)
      $$invalidate(0, parent = $$props2.parent);
    if ("dispatcher" in $$props2)
      dispatcher = $$props2.dispatcher;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*handle, config*/
    6) {
      $:
        handle.setAttrs(config);
    }
  };
  return [parent, config, handle, staticConfig];
}
var Circle = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, { config: 1, handle: 2, staticConfig: 3 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Circle",
      options,
      id: create_fragment3.name
    });
  }
  get config() {
    throw new Error("<Circle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set config(value) {
    throw new Error("<Circle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get handle() {
    throw new Error("<Circle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set handle(value) {
    throw new Error("<Circle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get staticConfig() {
    throw new Error("<Circle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set staticConfig(value) {
    throw new Error("<Circle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Circle_default = Circle;

// node_modules/svelte-konva/dist/Ellipse.svelte
var import_konva4 = __toESM(require_lib());
function create_fragment4(ctx) {
  const block = {
    c: noop,
    l: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance4($$self, $$props, $$invalidate) {
  let $parent;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Ellipse", slots, []);
  let { config } = $$props;
  let { handle = new import_konva4.default.Ellipse(config) } = $$props;
  let { staticConfig = false } = $$props;
  let parent = getParentContainer();
  validate_store(parent, "parent");
  component_subscribe($$self, parent, (value) => $$invalidate(4, $parent = value));
  let dispatcher = createEventDispatcher();
  onMount(() => {
    $parent.add(handle);
    if (!staticConfig) {
      handle.on("transformend", () => {
        copyExistingKeys(config, handle.getAttrs());
        $$invalidate(1, config);
      });
      handle.on("dragend", () => {
        copyExistingKeys(config, handle.getAttrs());
        $$invalidate(1, config);
      });
    }
    registerEvents(dispatcher, handle);
  });
  onDestroy(() => {
    handle.destroy();
  });
  $$self.$$.on_mount.push(function() {
    if (config === void 0 && !("config" in $$props || $$self.$$.bound[$$self.$$.props["config"]])) {
      console.warn("<Ellipse> was created without expected prop 'config'");
    }
  });
  const writable_props = ["config", "handle", "staticConfig"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Ellipse> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("config" in $$props2)
      $$invalidate(1, config = $$props2.config);
    if ("handle" in $$props2)
      $$invalidate(2, handle = $$props2.handle);
    if ("staticConfig" in $$props2)
      $$invalidate(3, staticConfig = $$props2.staticConfig);
  };
  $$self.$capture_state = () => ({
    Konva: import_konva4.default,
    onMount,
    onDestroy,
    createEventDispatcher,
    registerEvents,
    getParentContainer,
    copyExistingKeys,
    config,
    handle,
    staticConfig,
    parent,
    dispatcher,
    $parent
  });
  $$self.$inject_state = ($$props2) => {
    if ("config" in $$props2)
      $$invalidate(1, config = $$props2.config);
    if ("handle" in $$props2)
      $$invalidate(2, handle = $$props2.handle);
    if ("staticConfig" in $$props2)
      $$invalidate(3, staticConfig = $$props2.staticConfig);
    if ("parent" in $$props2)
      $$invalidate(0, parent = $$props2.parent);
    if ("dispatcher" in $$props2)
      dispatcher = $$props2.dispatcher;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*handle, config*/
    6) {
      $:
        handle.setAttrs(config);
    }
  };
  return [parent, config, handle, staticConfig];
}
var Ellipse = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment4, safe_not_equal, { config: 1, handle: 2, staticConfig: 3 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Ellipse",
      options,
      id: create_fragment4.name
    });
  }
  get config() {
    throw new Error("<Ellipse>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set config(value) {
    throw new Error("<Ellipse>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get handle() {
    throw new Error("<Ellipse>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set handle(value) {
    throw new Error("<Ellipse>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get staticConfig() {
    throw new Error("<Ellipse>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set staticConfig(value) {
    throw new Error("<Ellipse>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Ellipse_default = Ellipse;

// node_modules/svelte-konva/dist/Group.svelte
var import_konva5 = __toESM(require_lib());
function create_if_block(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(61:0) {#if isReady}",
    ctx
  });
  return block;
}
function create_fragment5(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*isReady*/
    ctx[0] && create_if_block(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*isReady*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*isReady*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance5($$self, $$props, $$invalidate) {
  let $parent;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Group", slots, ["default"]);
  let { config = {} } = $$props;
  let { handle = new import_konva5.default.Group(config) } = $$props;
  let { staticConfig = false } = $$props;
  let inner = writable(null);
  let dispatcher = createEventDispatcher();
  let isReady = false;
  let parent = getParentContainer();
  validate_store(parent, "parent");
  component_subscribe($$self, parent, (value) => $$invalidate(7, $parent = value));
  onMount(() => {
    $parent.add(handle);
    if (!staticConfig) {
      handle.on("transformend", () => {
        copyExistingKeys(config, handle.getAttrs());
        $$invalidate(2, config);
      });
      handle.on("dragend", () => {
        copyExistingKeys(config, handle.getAttrs());
        $$invalidate(2, config);
      });
    }
    registerEvents(dispatcher, handle);
    inner.set(handle);
    $$invalidate(0, isReady = true);
  });
  onDestroy(() => {
    if (handle) {
      handle.destroy();
    }
  });
  setContainerContext(Container.Group, inner);
  const writable_props = ["config", "handle", "staticConfig"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Group> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("config" in $$props2)
      $$invalidate(2, config = $$props2.config);
    if ("handle" in $$props2)
      $$invalidate(3, handle = $$props2.handle);
    if ("staticConfig" in $$props2)
      $$invalidate(4, staticConfig = $$props2.staticConfig);
    if ("$$scope" in $$props2)
      $$invalidate(5, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    Konva: import_konva5.default,
    onMount,
    onDestroy,
    createEventDispatcher,
    writable,
    Container,
    getParentContainer,
    setContainerContext,
    registerEvents,
    copyExistingKeys,
    config,
    handle,
    staticConfig,
    inner,
    dispatcher,
    isReady,
    parent,
    $parent
  });
  $$self.$inject_state = ($$props2) => {
    if ("config" in $$props2)
      $$invalidate(2, config = $$props2.config);
    if ("handle" in $$props2)
      $$invalidate(3, handle = $$props2.handle);
    if ("staticConfig" in $$props2)
      $$invalidate(4, staticConfig = $$props2.staticConfig);
    if ("inner" in $$props2)
      inner = $$props2.inner;
    if ("dispatcher" in $$props2)
      dispatcher = $$props2.dispatcher;
    if ("isReady" in $$props2)
      $$invalidate(0, isReady = $$props2.isReady);
    if ("parent" in $$props2)
      $$invalidate(1, parent = $$props2.parent);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*handle, config*/
    12) {
      $:
        if (handle) {
          handle.setAttrs(config);
        }
    }
  };
  return [isReady, parent, config, handle, staticConfig, $$scope, slots];
}
var Group = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance5, create_fragment5, safe_not_equal, { config: 2, handle: 3, staticConfig: 4 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Group",
      options,
      id: create_fragment5.name
    });
  }
  get config() {
    throw new Error("<Group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set config(value) {
    throw new Error("<Group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get handle() {
    throw new Error("<Group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set handle(value) {
    throw new Error("<Group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get staticConfig() {
    throw new Error("<Group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set staticConfig(value) {
    throw new Error("<Group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Group_default = Group;

// node_modules/svelte-konva/dist/Image.svelte
var import_konva6 = __toESM(require_lib());
function create_fragment6(ctx) {
  const block = {
    c: noop,
    l: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment6.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance6($$self, $$props, $$invalidate) {
  let $parent;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Image", slots, []);
  let { config } = $$props;
  let { handle = new import_konva6.default.Image(config) } = $$props;
  let { staticConfig = false } = $$props;
  let parent = getParentContainer();
  validate_store(parent, "parent");
  component_subscribe($$self, parent, (value) => $$invalidate(4, $parent = value));
  let dispatcher = createEventDispatcher();
  onMount(() => {
    $parent.add(handle);
    if (!staticConfig) {
      handle.on("transformend", () => {
        copyExistingKeys(config, handle.getAttrs());
        $$invalidate(1, config);
      });
      handle.on("dragend", () => {
        copyExistingKeys(config, handle.getAttrs());
        $$invalidate(1, config);
      });
    }
    registerEvents(dispatcher, handle);
  });
  onDestroy(() => {
    handle.destroy();
  });
  $$self.$$.on_mount.push(function() {
    if (config === void 0 && !("config" in $$props || $$self.$$.bound[$$self.$$.props["config"]])) {
      console.warn("<Image> was created without expected prop 'config'");
    }
  });
  const writable_props = ["config", "handle", "staticConfig"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Image> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("config" in $$props2)
      $$invalidate(1, config = $$props2.config);
    if ("handle" in $$props2)
      $$invalidate(2, handle = $$props2.handle);
    if ("staticConfig" in $$props2)
      $$invalidate(3, staticConfig = $$props2.staticConfig);
  };
  $$self.$capture_state = () => ({
    Konva: import_konva6.default,
    onMount,
    onDestroy,
    createEventDispatcher,
    registerEvents,
    getParentContainer,
    copyExistingKeys,
    config,
    handle,
    staticConfig,
    parent,
    dispatcher,
    $parent
  });
  $$self.$inject_state = ($$props2) => {
    if ("config" in $$props2)
      $$invalidate(1, config = $$props2.config);
    if ("handle" in $$props2)
      $$invalidate(2, handle = $$props2.handle);
    if ("staticConfig" in $$props2)
      $$invalidate(3, staticConfig = $$props2.staticConfig);
    if ("parent" in $$props2)
      $$invalidate(0, parent = $$props2.parent);
    if ("dispatcher" in $$props2)
      dispatcher = $$props2.dispatcher;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*handle, config*/
    6) {
      $:
        handle.setAttrs(config);
    }
  };
  return [parent, config, handle, staticConfig];
}
var Image = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance6, create_fragment6, safe_not_equal, { config: 1, handle: 2, staticConfig: 3 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Image",
      options,
      id: create_fragment6.name
    });
  }
  get config() {
    throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set config(value) {
    throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get handle() {
    throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set handle(value) {
    throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get staticConfig() {
    throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set staticConfig(value) {
    throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Image_default = Image;

// node_modules/svelte-konva/dist/Label.svelte
var import_konva7 = __toESM(require_lib());
function create_if_block2(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(58:0) {#if isReady}",
    ctx
  });
  return block;
}
function create_fragment7(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*isReady*/
    ctx[0] && create_if_block2(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*isReady*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*isReady*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block2(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment7.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance7($$self, $$props, $$invalidate) {
  let $parent;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Label", slots, ["default"]);
  let { config } = $$props;
  let { handle = new import_konva7.default.Label(config) } = $$props;
  let { staticConfig = false } = $$props;
  let inner = writable(null);
  let dispatcher = createEventDispatcher();
  let isReady = false;
  let parent = getParentContainer();
  validate_store(parent, "parent");
  component_subscribe($$self, parent, (value) => $$invalidate(7, $parent = value));
  onMount(() => {
    $parent.add(handle);
    if (!staticConfig) {
      handle.on("transformend", () => {
        copyExistingKeys(config, handle.getAttrs());
        $$invalidate(2, config);
      });
      handle.on("dragend", () => {
        copyExistingKeys(config, handle.getAttrs());
        $$invalidate(2, config);
      });
    }
    registerEvents(dispatcher, handle);
    inner.set(handle);
    $$invalidate(0, isReady = true);
  });
  onDestroy(() => {
    handle.destroy();
  });
  setContainerContext(Container.Label, inner);
  $$self.$$.on_mount.push(function() {
    if (config === void 0 && !("config" in $$props || $$self.$$.bound[$$self.$$.props["config"]])) {
      console.warn("<Label> was created without expected prop 'config'");
    }
  });
  const writable_props = ["config", "handle", "staticConfig"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Label> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("config" in $$props2)
      $$invalidate(2, config = $$props2.config);
    if ("handle" in $$props2)
      $$invalidate(3, handle = $$props2.handle);
    if ("staticConfig" in $$props2)
      $$invalidate(4, staticConfig = $$props2.staticConfig);
    if ("$$scope" in $$props2)
      $$invalidate(5, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    Konva: import_konva7.default,
    onMount,
    onDestroy,
    createEventDispatcher,
    writable,
    copyExistingKeys,
    Container,
    getParentContainer,
    setContainerContext,
    registerEvents,
    config,
    handle,
    staticConfig,
    inner,
    dispatcher,
    isReady,
    parent,
    $parent
  });
  $$self.$inject_state = ($$props2) => {
    if ("config" in $$props2)
      $$invalidate(2, config = $$props2.config);
    if ("handle" in $$props2)
      $$invalidate(3, handle = $$props2.handle);
    if ("staticConfig" in $$props2)
      $$invalidate(4, staticConfig = $$props2.staticConfig);
    if ("inner" in $$props2)
      inner = $$props2.inner;
    if ("dispatcher" in $$props2)
      dispatcher = $$props2.dispatcher;
    if ("isReady" in $$props2)
      $$invalidate(0, isReady = $$props2.isReady);
    if ("parent" in $$props2)
      $$invalidate(1, parent = $$props2.parent);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*handle, config*/
    12) {
      $:
        handle.setAttrs(config);
    }
  };
  return [isReady, parent, config, handle, staticConfig, $$scope, slots];
}
var Label = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance7, create_fragment7, safe_not_equal, { config: 2, handle: 3, staticConfig: 4 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Label",
      options,
      id: create_fragment7.name
    });
  }
  get config() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set config(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get handle() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set handle(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get staticConfig() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set staticConfig(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Label_default = Label;

// node_modules/svelte-konva/dist/Layer.svelte
var import_konva8 = __toESM(require_lib());
function create_if_block3(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block3.name,
    type: "if",
    source: "(63:0) {#if isReady}",
    ctx
  });
  return block;
}
function create_fragment8(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*isReady*/
    ctx[0] && create_if_block3(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*isReady*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*isReady*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block3(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment8.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance8($$self, $$props, $$invalidate) {
  let $parent;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Layer", slots, ["default"]);
  let { config = {} } = $$props;
  let { handle = new import_konva8.default.Layer(config) } = $$props;
  let { staticConfig = false } = $$props;
  let inner = writable(null);
  let dispatcher = createEventDispatcher();
  let isReady = false;
  let parent = getParentStage();
  validate_store(parent, "parent");
  component_subscribe($$self, parent, (value) => $$invalidate(7, $parent = value));
  onMount(() => {
    $parent.add(handle);
    if (!staticConfig) {
      handle.on("transformend", () => {
        copyExistingKeys(config, handle.getAttrs());
        $$invalidate(2, config);
      });
      handle.on("dragend", () => {
        copyExistingKeys(config, handle.getAttrs());
        $$invalidate(2, config);
      });
    }
    registerEvents(dispatcher, handle);
    inner.set(handle);
    $$invalidate(0, isReady = true);
  });
  onDestroy(() => {
    if (handle) {
      handle.destroy();
    }
  });
  setContainerContext(Container.Layer, inner);
  const writable_props = ["config", "handle", "staticConfig"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Layer> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("config" in $$props2)
      $$invalidate(2, config = $$props2.config);
    if ("handle" in $$props2)
      $$invalidate(3, handle = $$props2.handle);
    if ("staticConfig" in $$props2)
      $$invalidate(4, staticConfig = $$props2.staticConfig);
    if ("$$scope" in $$props2)
      $$invalidate(5, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    Konva: import_konva8.default,
    onMount,
    onDestroy,
    createEventDispatcher,
    writable,
    Container,
    getParentStage,
    setContainerContext,
    registerEvents,
    copyExistingKeys,
    config,
    handle,
    staticConfig,
    inner,
    dispatcher,
    isReady,
    parent,
    $parent
  });
  $$self.$inject_state = ($$props2) => {
    if ("config" in $$props2)
      $$invalidate(2, config = $$props2.config);
    if ("handle" in $$props2)
      $$invalidate(3, handle = $$props2.handle);
    if ("staticConfig" in $$props2)
      $$invalidate(4, staticConfig = $$props2.staticConfig);
    if ("inner" in $$props2)
      inner = $$props2.inner;
    if ("dispatcher" in $$props2)
      dispatcher = $$props2.dispatcher;
    if ("isReady" in $$props2)
      $$invalidate(0, isReady = $$props2.isReady);
    if ("parent" in $$props2)
      $$invalidate(1, parent = $$props2.parent);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*handle, config*/
    12) {
      $:
        if (handle) {
          handle.setAttrs(config);
        }
    }
  };
  return [isReady, parent, config, handle, staticConfig, $$scope, slots];
}
var Layer = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance8, create_fragment8, safe_not_equal, { config: 2, handle: 3, staticConfig: 4 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Layer",
      options,
      id: create_fragment8.name
    });
  }
  get config() {
    throw new Error("<Layer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set config(value) {
    throw new Error("<Layer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get handle() {
    throw new Error("<Layer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set handle(value) {
    throw new Error("<Layer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get staticConfig() {
    throw new Error("<Layer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set staticConfig(value) {
    throw new Error("<Layer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Layer_default = Layer;

// node_modules/svelte-konva/dist/Line.svelte
var import_konva9 = __toESM(require_lib());
function create_fragment9(ctx) {
  const block = {
    c: noop,
    l: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment9.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance9($$self, $$props, $$invalidate) {
  let $parent;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Line", slots, []);
  let { config } = $$props;
  let { handle = new import_konva9.default.Line(config) } = $$props;
  let { staticConfig = false } = $$props;
  let parent = getParentContainer();
  validate_store(parent, "parent");
  component_subscribe($$self, parent, (value) => $$invalidate(4, $parent = value));
  let dispatcher = createEventDispatcher();
  onMount(() => {
    $parent.add(handle);
    if (!staticConfig) {
      handle.on("transformend", () => {
        copyExistingKeys(config, handle.getAttrs());
        $$invalidate(1, config);
      });
      handle.on("dragend", () => {
        copyExistingKeys(config, handle.getAttrs());
        $$invalidate(1, config);
      });
    }
    registerEvents(dispatcher, handle);
  });
  onDestroy(() => {
    handle.destroy();
  });
  $$self.$$.on_mount.push(function() {
    if (config === void 0 && !("config" in $$props || $$self.$$.bound[$$self.$$.props["config"]])) {
      console.warn("<Line> was created without expected prop 'config'");
    }
  });
  const writable_props = ["config", "handle", "staticConfig"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Line> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("config" in $$props2)
      $$invalidate(1, config = $$props2.config);
    if ("handle" in $$props2)
      $$invalidate(2, handle = $$props2.handle);
    if ("staticConfig" in $$props2)
      $$invalidate(3, staticConfig = $$props2.staticConfig);
  };
  $$self.$capture_state = () => ({
    Konva: import_konva9.default,
    onMount,
    onDestroy,
    createEventDispatcher,
    registerEvents,
    getParentContainer,
    copyExistingKeys,
    config,
    handle,
    staticConfig,
    parent,
    dispatcher,
    $parent
  });
  $$self.$inject_state = ($$props2) => {
    if ("config" in $$props2)
      $$invalidate(1, config = $$props2.config);
    if ("handle" in $$props2)
      $$invalidate(2, handle = $$props2.handle);
    if ("staticConfig" in $$props2)
      $$invalidate(3, staticConfig = $$props2.staticConfig);
    if ("parent" in $$props2)
      $$invalidate(0, parent = $$props2.parent);
    if ("dispatcher" in $$props2)
      dispatcher = $$props2.dispatcher;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*handle, config*/
    6) {
      $:
        handle.setAttrs(config);
    }
  };
  return [parent, config, handle, staticConfig];
}
var Line = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance9, create_fragment9, safe_not_equal, { config: 1, handle: 2, staticConfig: 3 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Line",
      options,
      id: create_fragment9.name
    });
  }
  get config() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set config(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get handle() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set handle(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get staticConfig() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set staticConfig(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Line_default = Line;

// node_modules/svelte-konva/dist/Path.svelte
var import_konva10 = __toESM(require_lib());
function create_fragment10(ctx) {
  const block = {
    c: noop,
    l: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment10.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance10($$self, $$props, $$invalidate) {
  let $parent;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Path", slots, []);
  let { config } = $$props;
  let { handle = new import_konva10.default.Path(config) } = $$props;
  let { staticConfig = false } = $$props;
  let parent = getParentContainer();
  validate_store(parent, "parent");
  component_subscribe($$self, parent, (value) => $$invalidate(4, $parent = value));
  let dispatcher = createEventDispatcher();
  onMount(() => {
    $parent.add(handle);
    if (!staticConfig) {
      handle.on("transformend", () => {
        copyExistingKeys(config, handle.getAttrs());
        $$invalidate(1, config);
      });
      handle.on("dragend", () => {
        copyExistingKeys(config, handle.getAttrs());
        $$invalidate(1, config);
      });
    }
    registerEvents(dispatcher, handle);
  });
  onDestroy(() => {
    handle.destroy();
  });
  $$self.$$.on_mount.push(function() {
    if (config === void 0 && !("config" in $$props || $$self.$$.bound[$$self.$$.props["config"]])) {
      console.warn("<Path> was created without expected prop 'config'");
    }
  });
  const writable_props = ["config", "handle", "staticConfig"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Path> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("config" in $$props2)
      $$invalidate(1, config = $$props2.config);
    if ("handle" in $$props2)
      $$invalidate(2, handle = $$props2.handle);
    if ("staticConfig" in $$props2)
      $$invalidate(3, staticConfig = $$props2.staticConfig);
  };
  $$self.$capture_state = () => ({
    Konva: import_konva10.default,
    onMount,
    onDestroy,
    createEventDispatcher,
    registerEvents,
    getParentContainer,
    copyExistingKeys,
    config,
    handle,
    staticConfig,
    parent,
    dispatcher,
    $parent
  });
  $$self.$inject_state = ($$props2) => {
    if ("config" in $$props2)
      $$invalidate(1, config = $$props2.config);
    if ("handle" in $$props2)
      $$invalidate(2, handle = $$props2.handle);
    if ("staticConfig" in $$props2)
      $$invalidate(3, staticConfig = $$props2.staticConfig);
    if ("parent" in $$props2)
      $$invalidate(0, parent = $$props2.parent);
    if ("dispatcher" in $$props2)
      dispatcher = $$props2.dispatcher;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*handle, config*/
    6) {
      $:
        handle.setAttrs(config);
    }
  };
  return [parent, config, handle, staticConfig];
}
var Path = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance10, create_fragment10, safe_not_equal, { config: 1, handle: 2, staticConfig: 3 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Path",
      options,
      id: create_fragment10.name
    });
  }
  get config() {
    throw new Error("<Path>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set config(value) {
    throw new Error("<Path>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get handle() {
    throw new Error("<Path>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set handle(value) {
    throw new Error("<Path>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get staticConfig() {
    throw new Error("<Path>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set staticConfig(value) {
    throw new Error("<Path>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Path_default = Path;

// node_modules/svelte-konva/dist/Rect.svelte
var import_konva11 = __toESM(require_lib());
function create_fragment11(ctx) {
  const block = {
    c: noop,
    l: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment11.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance11($$self, $$props, $$invalidate) {
  let $parent;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Rect", slots, []);
  let { config } = $$props;
  let { handle = new import_konva11.default.Rect(config) } = $$props;
  let { staticConfig = false } = $$props;
  let parent = getParentContainer();
  validate_store(parent, "parent");
  component_subscribe($$self, parent, (value) => $$invalidate(4, $parent = value));
  let dispatcher = createEventDispatcher();
  onMount(() => {
    $parent.add(handle);
    if (!staticConfig) {
      handle.on("transformend", () => {
        copyExistingKeys(config, handle.getAttrs());
        $$invalidate(1, config);
      });
      handle.on("dragend", () => {
        copyExistingKeys(config, handle.getAttrs());
        $$invalidate(1, config);
      });
    }
    registerEvents(dispatcher, handle);
  });
  onDestroy(() => {
    handle.destroy();
  });
  $$self.$$.on_mount.push(function() {
    if (config === void 0 && !("config" in $$props || $$self.$$.bound[$$self.$$.props["config"]])) {
      console.warn("<Rect> was created without expected prop 'config'");
    }
  });
  const writable_props = ["config", "handle", "staticConfig"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Rect> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("config" in $$props2)
      $$invalidate(1, config = $$props2.config);
    if ("handle" in $$props2)
      $$invalidate(2, handle = $$props2.handle);
    if ("staticConfig" in $$props2)
      $$invalidate(3, staticConfig = $$props2.staticConfig);
  };
  $$self.$capture_state = () => ({
    Konva: import_konva11.default,
    onMount,
    onDestroy,
    createEventDispatcher,
    registerEvents,
    getParentContainer,
    copyExistingKeys,
    config,
    handle,
    staticConfig,
    parent,
    dispatcher,
    $parent
  });
  $$self.$inject_state = ($$props2) => {
    if ("config" in $$props2)
      $$invalidate(1, config = $$props2.config);
    if ("handle" in $$props2)
      $$invalidate(2, handle = $$props2.handle);
    if ("staticConfig" in $$props2)
      $$invalidate(3, staticConfig = $$props2.staticConfig);
    if ("parent" in $$props2)
      $$invalidate(0, parent = $$props2.parent);
    if ("dispatcher" in $$props2)
      dispatcher = $$props2.dispatcher;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*handle, config*/
    6) {
      $:
        handle.setAttrs(config);
    }
  };
  return [parent, config, handle, staticConfig];
}
var Rect = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance11, create_fragment11, safe_not_equal, { config: 1, handle: 2, staticConfig: 3 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Rect",
      options,
      id: create_fragment11.name
    });
  }
  get config() {
    throw new Error("<Rect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set config(value) {
    throw new Error("<Rect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get handle() {
    throw new Error("<Rect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set handle(value) {
    throw new Error("<Rect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get staticConfig() {
    throw new Error("<Rect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set staticConfig(value) {
    throw new Error("<Rect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Rect_default = Rect;

// node_modules/svelte-konva/dist/RegularPolygon.svelte
var import_konva12 = __toESM(require_lib());
function create_fragment12(ctx) {
  const block = {
    c: noop,
    l: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment12.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance12($$self, $$props, $$invalidate) {
  let $parent;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("RegularPolygon", slots, []);
  let { config } = $$props;
  let { handle = new import_konva12.default.RegularPolygon(config) } = $$props;
  let { staticConfig = false } = $$props;
  let parent = getParentContainer();
  validate_store(parent, "parent");
  component_subscribe($$self, parent, (value) => $$invalidate(4, $parent = value));
  let dispatcher = createEventDispatcher();
  onMount(() => {
    $parent.add(handle);
    if (!staticConfig) {
      handle.on("transformend", () => {
        copyExistingKeys(config, handle.getAttrs());
        $$invalidate(1, config);
      });
      handle.on("dragend", () => {
        copyExistingKeys(config, handle.getAttrs());
        $$invalidate(1, config);
      });
    }
    registerEvents(dispatcher, handle);
  });
  onDestroy(() => {
    handle.destroy();
  });
  $$self.$$.on_mount.push(function() {
    if (config === void 0 && !("config" in $$props || $$self.$$.bound[$$self.$$.props["config"]])) {
      console.warn("<RegularPolygon> was created without expected prop 'config'");
    }
  });
  const writable_props = ["config", "handle", "staticConfig"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<RegularPolygon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("config" in $$props2)
      $$invalidate(1, config = $$props2.config);
    if ("handle" in $$props2)
      $$invalidate(2, handle = $$props2.handle);
    if ("staticConfig" in $$props2)
      $$invalidate(3, staticConfig = $$props2.staticConfig);
  };
  $$self.$capture_state = () => ({
    Konva: import_konva12.default,
    onMount,
    onDestroy,
    createEventDispatcher,
    registerEvents,
    getParentContainer,
    copyExistingKeys,
    config,
    handle,
    staticConfig,
    parent,
    dispatcher,
    $parent
  });
  $$self.$inject_state = ($$props2) => {
    if ("config" in $$props2)
      $$invalidate(1, config = $$props2.config);
    if ("handle" in $$props2)
      $$invalidate(2, handle = $$props2.handle);
    if ("staticConfig" in $$props2)
      $$invalidate(3, staticConfig = $$props2.staticConfig);
    if ("parent" in $$props2)
      $$invalidate(0, parent = $$props2.parent);
    if ("dispatcher" in $$props2)
      dispatcher = $$props2.dispatcher;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*handle, config*/
    6) {
      $:
        handle.setAttrs(config);
    }
  };
  return [parent, config, handle, staticConfig];
}
var RegularPolygon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance12, create_fragment12, safe_not_equal, { config: 1, handle: 2, staticConfig: 3 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "RegularPolygon",
      options,
      id: create_fragment12.name
    });
  }
  get config() {
    throw new Error("<RegularPolygon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set config(value) {
    throw new Error("<RegularPolygon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get handle() {
    throw new Error("<RegularPolygon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set handle(value) {
    throw new Error("<RegularPolygon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get staticConfig() {
    throw new Error("<RegularPolygon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set staticConfig(value) {
    throw new Error("<RegularPolygon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var RegularPolygon_default = RegularPolygon;

// node_modules/svelte-konva/dist/Ring.svelte
var import_konva13 = __toESM(require_lib());
function create_fragment13(ctx) {
  const block = {
    c: noop,
    l: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment13.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance13($$self, $$props, $$invalidate) {
  let $parent;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Ring", slots, []);
  let { config } = $$props;
  let { handle = new import_konva13.default.Ring(config) } = $$props;
  let { staticConfig = false } = $$props;
  let parent = getParentContainer();
  validate_store(parent, "parent");
  component_subscribe($$self, parent, (value) => $$invalidate(4, $parent = value));
  let dispatcher = createEventDispatcher();
  onMount(() => {
    $parent.add(handle);
    if (!staticConfig) {
      handle.on("transformend", () => {
        copyExistingKeys(config, handle.getAttrs());
        $$invalidate(1, config);
      });
      handle.on("dragend", () => {
        copyExistingKeys(config, handle.getAttrs());
        $$invalidate(1, config);
      });
    }
    registerEvents(dispatcher, handle);
  });
  onDestroy(() => {
    handle.destroy();
  });
  $$self.$$.on_mount.push(function() {
    if (config === void 0 && !("config" in $$props || $$self.$$.bound[$$self.$$.props["config"]])) {
      console.warn("<Ring> was created without expected prop 'config'");
    }
  });
  const writable_props = ["config", "handle", "staticConfig"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Ring> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("config" in $$props2)
      $$invalidate(1, config = $$props2.config);
    if ("handle" in $$props2)
      $$invalidate(2, handle = $$props2.handle);
    if ("staticConfig" in $$props2)
      $$invalidate(3, staticConfig = $$props2.staticConfig);
  };
  $$self.$capture_state = () => ({
    Konva: import_konva13.default,
    onMount,
    onDestroy,
    createEventDispatcher,
    registerEvents,
    getParentContainer,
    copyExistingKeys,
    config,
    handle,
    staticConfig,
    parent,
    dispatcher,
    $parent
  });
  $$self.$inject_state = ($$props2) => {
    if ("config" in $$props2)
      $$invalidate(1, config = $$props2.config);
    if ("handle" in $$props2)
      $$invalidate(2, handle = $$props2.handle);
    if ("staticConfig" in $$props2)
      $$invalidate(3, staticConfig = $$props2.staticConfig);
    if ("parent" in $$props2)
      $$invalidate(0, parent = $$props2.parent);
    if ("dispatcher" in $$props2)
      dispatcher = $$props2.dispatcher;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*handle, config*/
    6) {
      $:
        handle.setAttrs(config);
    }
  };
  return [parent, config, handle, staticConfig];
}
var Ring = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance13, create_fragment13, safe_not_equal, { config: 1, handle: 2, staticConfig: 3 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Ring",
      options,
      id: create_fragment13.name
    });
  }
  get config() {
    throw new Error("<Ring>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set config(value) {
    throw new Error("<Ring>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get handle() {
    throw new Error("<Ring>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set handle(value) {
    throw new Error("<Ring>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get staticConfig() {
    throw new Error("<Ring>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set staticConfig(value) {
    throw new Error("<Ring>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Ring_default = Ring;

// node_modules/svelte-konva/dist/Shape.svelte
var import_konva14 = __toESM(require_lib());
function create_fragment14(ctx) {
  const block = {
    c: noop,
    l: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment14.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance14($$self, $$props, $$invalidate) {
  let $parent;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Shape", slots, []);
  let { config } = $$props;
  let { handle = new import_konva14.default.Shape(config) } = $$props;
  let { staticConfig = false } = $$props;
  let parent = getParentContainer();
  validate_store(parent, "parent");
  component_subscribe($$self, parent, (value) => $$invalidate(4, $parent = value));
  let dispatcher = createEventDispatcher();
  onMount(() => {
    $parent.add(handle);
    if (!staticConfig) {
      handle.on("transformend", () => {
        copyExistingKeys(config, handle.getAttrs());
        $$invalidate(1, config);
      });
      handle.on("dragend", () => {
        copyExistingKeys(config, handle.getAttrs());
        $$invalidate(1, config);
      });
    }
    registerEvents(dispatcher, handle);
  });
  onDestroy(() => {
    handle.destroy();
  });
  $$self.$$.on_mount.push(function() {
    if (config === void 0 && !("config" in $$props || $$self.$$.bound[$$self.$$.props["config"]])) {
      console.warn("<Shape> was created without expected prop 'config'");
    }
  });
  const writable_props = ["config", "handle", "staticConfig"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Shape> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("config" in $$props2)
      $$invalidate(1, config = $$props2.config);
    if ("handle" in $$props2)
      $$invalidate(2, handle = $$props2.handle);
    if ("staticConfig" in $$props2)
      $$invalidate(3, staticConfig = $$props2.staticConfig);
  };
  $$self.$capture_state = () => ({
    Konva: import_konva14.default,
    onMount,
    onDestroy,
    createEventDispatcher,
    registerEvents,
    getParentContainer,
    copyExistingKeys,
    config,
    handle,
    staticConfig,
    parent,
    dispatcher,
    $parent
  });
  $$self.$inject_state = ($$props2) => {
    if ("config" in $$props2)
      $$invalidate(1, config = $$props2.config);
    if ("handle" in $$props2)
      $$invalidate(2, handle = $$props2.handle);
    if ("staticConfig" in $$props2)
      $$invalidate(3, staticConfig = $$props2.staticConfig);
    if ("parent" in $$props2)
      $$invalidate(0, parent = $$props2.parent);
    if ("dispatcher" in $$props2)
      dispatcher = $$props2.dispatcher;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*handle, config*/
    6) {
      $:
        handle.setAttrs(config);
    }
  };
  return [parent, config, handle, staticConfig];
}
var Shape = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance14, create_fragment14, safe_not_equal, { config: 1, handle: 2, staticConfig: 3 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Shape",
      options,
      id: create_fragment14.name
    });
  }
  get config() {
    throw new Error("<Shape>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set config(value) {
    throw new Error("<Shape>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get handle() {
    throw new Error("<Shape>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set handle(value) {
    throw new Error("<Shape>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get staticConfig() {
    throw new Error("<Shape>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set staticConfig(value) {
    throw new Error("<Shape>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Shape_default = Shape;

// node_modules/svelte-konva/dist/Sprite.svelte
var import_konva15 = __toESM(require_lib());
function create_fragment15(ctx) {
  const block = {
    c: noop,
    l: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment15.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance15($$self, $$props, $$invalidate) {
  let $parent;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Sprite", slots, []);
  let { config } = $$props;
  let { handle = new import_konva15.default.Sprite(config) } = $$props;
  let { staticConfig = false } = $$props;
  let parent = getParentContainer();
  validate_store(parent, "parent");
  component_subscribe($$self, parent, (value) => $$invalidate(4, $parent = value));
  let dispatcher = createEventDispatcher();
  onMount(() => {
    $parent.add(handle);
    if (!staticConfig) {
      handle.on("transformend", () => {
        copyExistingKeys(config, handle.getAttrs());
        $$invalidate(1, config);
      });
      handle.on("dragend", () => {
        copyExistingKeys(config, handle.getAttrs());
        $$invalidate(1, config);
      });
    }
    registerEvents(dispatcher, handle);
  });
  onDestroy(() => {
    handle.destroy();
  });
  $$self.$$.on_mount.push(function() {
    if (config === void 0 && !("config" in $$props || $$self.$$.bound[$$self.$$.props["config"]])) {
      console.warn("<Sprite> was created without expected prop 'config'");
    }
  });
  const writable_props = ["config", "handle", "staticConfig"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Sprite> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("config" in $$props2)
      $$invalidate(1, config = $$props2.config);
    if ("handle" in $$props2)
      $$invalidate(2, handle = $$props2.handle);
    if ("staticConfig" in $$props2)
      $$invalidate(3, staticConfig = $$props2.staticConfig);
  };
  $$self.$capture_state = () => ({
    Konva: import_konva15.default,
    onMount,
    onDestroy,
    createEventDispatcher,
    registerEvents,
    getParentContainer,
    copyExistingKeys,
    config,
    handle,
    staticConfig,
    parent,
    dispatcher,
    $parent
  });
  $$self.$inject_state = ($$props2) => {
    if ("config" in $$props2)
      $$invalidate(1, config = $$props2.config);
    if ("handle" in $$props2)
      $$invalidate(2, handle = $$props2.handle);
    if ("staticConfig" in $$props2)
      $$invalidate(3, staticConfig = $$props2.staticConfig);
    if ("parent" in $$props2)
      $$invalidate(0, parent = $$props2.parent);
    if ("dispatcher" in $$props2)
      dispatcher = $$props2.dispatcher;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*handle, config*/
    6) {
      $:
        handle.setAttrs(config);
    }
  };
  return [parent, config, handle, staticConfig];
}
var Sprite = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance15, create_fragment15, safe_not_equal, { config: 1, handle: 2, staticConfig: 3 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Sprite",
      options,
      id: create_fragment15.name
    });
  }
  get config() {
    throw new Error("<Sprite>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set config(value) {
    throw new Error("<Sprite>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get handle() {
    throw new Error("<Sprite>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set handle(value) {
    throw new Error("<Sprite>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get staticConfig() {
    throw new Error("<Sprite>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set staticConfig(value) {
    throw new Error("<Sprite>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Sprite_default = Sprite;

// node_modules/svelte-konva/dist/Stage.svelte
var import_konva16 = __toESM(require_lib());
var file = "node_modules/svelte-konva/dist/Stage.svelte";
function create_if_block4(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block4.name,
    type: "if",
    source: "(60:1) {#if isReady}",
    ctx
  });
  return block;
}
function create_fragment16(ctx) {
  let div;
  let current;
  let if_block = (
    /*isReady*/
    ctx[1] && create_if_block4(ctx)
  );
  let div_levels = [
    /*$$restProps*/
    ctx[2]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (if_block)
        if_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file, 58, 0, 1921);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      ctx[8](div);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*isReady*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*isReady*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block4(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [dirty & /*$$restProps*/
      4 && /*$$restProps*/
      ctx2[2]]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (if_block)
        if_block.d();
      ctx[8](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment16.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance16($$self, $$props, $$invalidate) {
  const omit_props_names = ["config", "handle", "staticConfig"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Stage", slots, ["default"]);
  let { config } = $$props;
  let { handle = null } = $$props;
  let { staticConfig = false } = $$props;
  let inner = writable(null);
  let stage;
  let dispatcher = createEventDispatcher();
  let isReady = false;
  onMount(() => {
    $$invalidate(4, handle = new import_konva16.default.Stage({ container: stage, ...config }));
    if (!staticConfig) {
      handle.on("dragend", () => {
        copyExistingKeys(config, handle.getAttrs());
        $$invalidate(3, config);
      });
    }
    registerEvents(dispatcher, handle);
    inner.set(handle);
    $$invalidate(1, isReady = true);
  });
  onDestroy(() => {
    if (handle) {
      handle.destroy();
    }
  });
  setContainerContext(Container.Stage, inner);
  $$self.$$.on_mount.push(function() {
    if (config === void 0 && !("config" in $$props || $$self.$$.bound[$$self.$$.props["config"]])) {
      console.warn("<Stage> was created without expected prop 'config'");
    }
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      stage = $$value;
      $$invalidate(0, stage);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("config" in $$new_props)
      $$invalidate(3, config = $$new_props.config);
    if ("handle" in $$new_props)
      $$invalidate(4, handle = $$new_props.handle);
    if ("staticConfig" in $$new_props)
      $$invalidate(5, staticConfig = $$new_props.staticConfig);
    if ("$$scope" in $$new_props)
      $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    Konva: import_konva16.default,
    onMount,
    onDestroy,
    createEventDispatcher,
    writable,
    registerEvents,
    Container,
    setContainerContext,
    copyExistingKeys,
    config,
    handle,
    staticConfig,
    inner,
    stage,
    dispatcher,
    isReady
  });
  $$self.$inject_state = ($$new_props) => {
    if ("config" in $$props)
      $$invalidate(3, config = $$new_props.config);
    if ("handle" in $$props)
      $$invalidate(4, handle = $$new_props.handle);
    if ("staticConfig" in $$props)
      $$invalidate(5, staticConfig = $$new_props.staticConfig);
    if ("inner" in $$props)
      inner = $$new_props.inner;
    if ("stage" in $$props)
      $$invalidate(0, stage = $$new_props.stage);
    if ("dispatcher" in $$props)
      dispatcher = $$new_props.dispatcher;
    if ("isReady" in $$props)
      $$invalidate(1, isReady = $$new_props.isReady);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*handle, config*/
    24) {
      $:
        if (handle) {
          handle.setAttrs(config);
        }
    }
  };
  return [
    stage,
    isReady,
    $$restProps,
    config,
    handle,
    staticConfig,
    $$scope,
    slots,
    div_binding
  ];
}
var Stage = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance16, create_fragment16, safe_not_equal, { config: 3, handle: 4, staticConfig: 5 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Stage",
      options,
      id: create_fragment16.name
    });
  }
  get config() {
    throw new Error("<Stage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set config(value) {
    throw new Error("<Stage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get handle() {
    throw new Error("<Stage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set handle(value) {
    throw new Error("<Stage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get staticConfig() {
    throw new Error("<Stage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set staticConfig(value) {
    throw new Error("<Stage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Stage_default = Stage;

// node_modules/svelte-konva/dist/Star.svelte
var import_konva17 = __toESM(require_lib());
function create_fragment17(ctx) {
  const block = {
    c: noop,
    l: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment17.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance17($$self, $$props, $$invalidate) {
  let $parent;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Star", slots, []);
  let { config } = $$props;
  let { handle = new import_konva17.default.Star(config) } = $$props;
  let { staticConfig = false } = $$props;
  let parent = getParentContainer();
  validate_store(parent, "parent");
  component_subscribe($$self, parent, (value) => $$invalidate(4, $parent = value));
  let dispatcher = createEventDispatcher();
  onMount(() => {
    $parent.add(handle);
    if (!staticConfig) {
      handle.on("transformend", () => {
        copyExistingKeys(config, handle.getAttrs());
        $$invalidate(1, config);
      });
      handle.on("dragend", () => {
        copyExistingKeys(config, handle.getAttrs());
        $$invalidate(1, config);
      });
    }
    registerEvents(dispatcher, handle);
  });
  onDestroy(() => {
    handle.destroy();
  });
  $$self.$$.on_mount.push(function() {
    if (config === void 0 && !("config" in $$props || $$self.$$.bound[$$self.$$.props["config"]])) {
      console.warn("<Star> was created without expected prop 'config'");
    }
  });
  const writable_props = ["config", "handle", "staticConfig"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Star> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("config" in $$props2)
      $$invalidate(1, config = $$props2.config);
    if ("handle" in $$props2)
      $$invalidate(2, handle = $$props2.handle);
    if ("staticConfig" in $$props2)
      $$invalidate(3, staticConfig = $$props2.staticConfig);
  };
  $$self.$capture_state = () => ({
    Konva: import_konva17.default,
    onMount,
    onDestroy,
    createEventDispatcher,
    registerEvents,
    getParentContainer,
    copyExistingKeys,
    config,
    handle,
    staticConfig,
    parent,
    dispatcher,
    $parent
  });
  $$self.$inject_state = ($$props2) => {
    if ("config" in $$props2)
      $$invalidate(1, config = $$props2.config);
    if ("handle" in $$props2)
      $$invalidate(2, handle = $$props2.handle);
    if ("staticConfig" in $$props2)
      $$invalidate(3, staticConfig = $$props2.staticConfig);
    if ("parent" in $$props2)
      $$invalidate(0, parent = $$props2.parent);
    if ("dispatcher" in $$props2)
      dispatcher = $$props2.dispatcher;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*handle, config*/
    6) {
      $:
        handle.setAttrs(config);
    }
  };
  return [parent, config, handle, staticConfig];
}
var Star = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance17, create_fragment17, safe_not_equal, { config: 1, handle: 2, staticConfig: 3 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Star",
      options,
      id: create_fragment17.name
    });
  }
  get config() {
    throw new Error("<Star>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set config(value) {
    throw new Error("<Star>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get handle() {
    throw new Error("<Star>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set handle(value) {
    throw new Error("<Star>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get staticConfig() {
    throw new Error("<Star>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set staticConfig(value) {
    throw new Error("<Star>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Star_default = Star;

// node_modules/svelte-konva/dist/Text.svelte
var import_konva18 = __toESM(require_lib());
function create_fragment18(ctx) {
  const block = {
    c: noop,
    l: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment18.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance18($$self, $$props, $$invalidate) {
  let $parent;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Text", slots, []);
  let { config } = $$props;
  let { handle = new import_konva18.default.Text(config) } = $$props;
  let { staticConfig = false } = $$props;
  let parent = getParentContainer();
  validate_store(parent, "parent");
  component_subscribe($$self, parent, (value) => $$invalidate(4, $parent = value));
  let dispatcher = createEventDispatcher();
  onMount(() => {
    $parent.add(handle);
    if (!staticConfig) {
      handle.on("transformend", () => {
        copyExistingKeys(config, handle.getAttrs());
        $$invalidate(1, config);
      });
      handle.on("dragend", () => {
        copyExistingKeys(config, handle.getAttrs());
        $$invalidate(1, config);
      });
    }
    registerEvents(dispatcher, handle);
  });
  onDestroy(() => {
    handle.destroy();
  });
  $$self.$$.on_mount.push(function() {
    if (config === void 0 && !("config" in $$props || $$self.$$.bound[$$self.$$.props["config"]])) {
      console.warn("<Text> was created without expected prop 'config'");
    }
  });
  const writable_props = ["config", "handle", "staticConfig"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Text> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("config" in $$props2)
      $$invalidate(1, config = $$props2.config);
    if ("handle" in $$props2)
      $$invalidate(2, handle = $$props2.handle);
    if ("staticConfig" in $$props2)
      $$invalidate(3, staticConfig = $$props2.staticConfig);
  };
  $$self.$capture_state = () => ({
    Konva: import_konva18.default,
    onMount,
    onDestroy,
    createEventDispatcher,
    registerEvents,
    getParentContainer,
    copyExistingKeys,
    config,
    handle,
    staticConfig,
    parent,
    dispatcher,
    $parent
  });
  $$self.$inject_state = ($$props2) => {
    if ("config" in $$props2)
      $$invalidate(1, config = $$props2.config);
    if ("handle" in $$props2)
      $$invalidate(2, handle = $$props2.handle);
    if ("staticConfig" in $$props2)
      $$invalidate(3, staticConfig = $$props2.staticConfig);
    if ("parent" in $$props2)
      $$invalidate(0, parent = $$props2.parent);
    if ("dispatcher" in $$props2)
      dispatcher = $$props2.dispatcher;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*handle, config*/
    6) {
      $:
        handle.setAttrs(config);
    }
  };
  return [parent, config, handle, staticConfig];
}
var Text = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance18, create_fragment18, safe_not_equal, { config: 1, handle: 2, staticConfig: 3 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Text",
      options,
      id: create_fragment18.name
    });
  }
  get config() {
    throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set config(value) {
    throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get handle() {
    throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set handle(value) {
    throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get staticConfig() {
    throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set staticConfig(value) {
    throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Text_default = Text;

// node_modules/svelte-konva/dist/TextPath.svelte
var import_konva19 = __toESM(require_lib());
function create_fragment19(ctx) {
  const block = {
    c: noop,
    l: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment19.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance19($$self, $$props, $$invalidate) {
  let $parent;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TextPath", slots, []);
  let { config } = $$props;
  let { handle = new import_konva19.default.TextPath(config) } = $$props;
  let { staticConfig = false } = $$props;
  let parent = getParentContainer();
  validate_store(parent, "parent");
  component_subscribe($$self, parent, (value) => $$invalidate(4, $parent = value));
  let dispatcher = createEventDispatcher();
  onMount(() => {
    $parent.add(handle);
    if (!staticConfig) {
      handle.on("transformend", () => {
        copyExistingKeys(config, handle.getAttrs());
        $$invalidate(1, config);
      });
      handle.on("dragend", () => {
        copyExistingKeys(config, handle.getAttrs());
        $$invalidate(1, config);
      });
    }
    registerEvents(dispatcher, handle);
  });
  onDestroy(() => {
    handle.destroy();
  });
  $$self.$$.on_mount.push(function() {
    if (config === void 0 && !("config" in $$props || $$self.$$.bound[$$self.$$.props["config"]])) {
      console.warn("<TextPath> was created without expected prop 'config'");
    }
  });
  const writable_props = ["config", "handle", "staticConfig"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<TextPath> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("config" in $$props2)
      $$invalidate(1, config = $$props2.config);
    if ("handle" in $$props2)
      $$invalidate(2, handle = $$props2.handle);
    if ("staticConfig" in $$props2)
      $$invalidate(3, staticConfig = $$props2.staticConfig);
  };
  $$self.$capture_state = () => ({
    Konva: import_konva19.default,
    onMount,
    onDestroy,
    createEventDispatcher,
    registerEvents,
    getParentContainer,
    copyExistingKeys,
    config,
    handle,
    staticConfig,
    parent,
    dispatcher,
    $parent
  });
  $$self.$inject_state = ($$props2) => {
    if ("config" in $$props2)
      $$invalidate(1, config = $$props2.config);
    if ("handle" in $$props2)
      $$invalidate(2, handle = $$props2.handle);
    if ("staticConfig" in $$props2)
      $$invalidate(3, staticConfig = $$props2.staticConfig);
    if ("parent" in $$props2)
      $$invalidate(0, parent = $$props2.parent);
    if ("dispatcher" in $$props2)
      dispatcher = $$props2.dispatcher;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*handle, config*/
    6) {
      $:
        handle.setAttrs(config);
    }
  };
  return [parent, config, handle, staticConfig];
}
var TextPath = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance19, create_fragment19, safe_not_equal, { config: 1, handle: 2, staticConfig: 3 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TextPath",
      options,
      id: create_fragment19.name
    });
  }
  get config() {
    throw new Error("<TextPath>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set config(value) {
    throw new Error("<TextPath>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get handle() {
    throw new Error("<TextPath>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set handle(value) {
    throw new Error("<TextPath>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get staticConfig() {
    throw new Error("<TextPath>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set staticConfig(value) {
    throw new Error("<TextPath>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TextPath_default = TextPath;

// node_modules/svelte-konva/dist/Transformer.svelte
var import_konva20 = __toESM(require_lib());
function create_fragment20(ctx) {
  const block = {
    c: noop,
    l: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment20.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance20($$self, $$props, $$invalidate) {
  let $parent;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Transformer", slots, []);
  let { config = {} } = $$props;
  let { handle = new import_konva20.default.Transformer(config) } = $$props;
  let { staticConfig = false } = $$props;
  let parent = getParentContainer();
  validate_store(parent, "parent");
  component_subscribe($$self, parent, (value) => $$invalidate(4, $parent = value));
  let dispatcher = createEventDispatcher();
  onMount(() => {
    $parent.add(handle);
    if (!staticConfig) {
      handle.on("transformend", () => {
        copyExistingKeys(config, handle.getAttrs());
        $$invalidate(1, config);
      });
      handle.on("dragend", () => {
        copyExistingKeys(config, handle.getAttrs());
        $$invalidate(1, config);
      });
    }
    registerEvents(dispatcher, handle);
  });
  onDestroy(() => {
    if (handle) {
      handle.destroy();
    }
  });
  const writable_props = ["config", "handle", "staticConfig"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Transformer> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("config" in $$props2)
      $$invalidate(1, config = $$props2.config);
    if ("handle" in $$props2)
      $$invalidate(2, handle = $$props2.handle);
    if ("staticConfig" in $$props2)
      $$invalidate(3, staticConfig = $$props2.staticConfig);
  };
  $$self.$capture_state = () => ({
    Konva: import_konva20.default,
    onMount,
    onDestroy,
    createEventDispatcher,
    registerEvents,
    getParentContainer,
    copyExistingKeys,
    config,
    handle,
    staticConfig,
    parent,
    dispatcher,
    $parent
  });
  $$self.$inject_state = ($$props2) => {
    if ("config" in $$props2)
      $$invalidate(1, config = $$props2.config);
    if ("handle" in $$props2)
      $$invalidate(2, handle = $$props2.handle);
    if ("staticConfig" in $$props2)
      $$invalidate(3, staticConfig = $$props2.staticConfig);
    if ("parent" in $$props2)
      $$invalidate(0, parent = $$props2.parent);
    if ("dispatcher" in $$props2)
      dispatcher = $$props2.dispatcher;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*handle, config*/
    6) {
      $:
        if (handle) {
          handle.setAttrs(config);
        }
    }
  };
  return [parent, config, handle, staticConfig];
}
var Transformer = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance20, create_fragment20, safe_not_equal, { config: 1, handle: 2, staticConfig: 3 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Transformer",
      options,
      id: create_fragment20.name
    });
  }
  get config() {
    throw new Error("<Transformer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set config(value) {
    throw new Error("<Transformer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get handle() {
    throw new Error("<Transformer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set handle(value) {
    throw new Error("<Transformer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get staticConfig() {
    throw new Error("<Transformer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set staticConfig(value) {
    throw new Error("<Transformer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Transformer_default = Transformer;

// node_modules/svelte-konva/dist/Wedge.svelte
var import_konva21 = __toESM(require_lib());
function create_fragment21(ctx) {
  const block = {
    c: noop,
    l: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment21.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance21($$self, $$props, $$invalidate) {
  let $parent;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Wedge", slots, []);
  let { config } = $$props;
  let { handle = new import_konva21.default.Wedge(config) } = $$props;
  let { staticConfig = false } = $$props;
  let parent = getParentContainer();
  validate_store(parent, "parent");
  component_subscribe($$self, parent, (value) => $$invalidate(4, $parent = value));
  let dispatcher = createEventDispatcher();
  onMount(() => {
    $parent.add(handle);
    if (!staticConfig) {
      handle.on("transformend", () => {
        copyExistingKeys(config, handle.getAttrs());
        $$invalidate(1, config);
      });
      handle.on("dragend", () => {
        copyExistingKeys(config, handle.getAttrs());
        $$invalidate(1, config);
      });
    }
    registerEvents(dispatcher, handle);
  });
  onDestroy(() => {
    handle.destroy();
  });
  $$self.$$.on_mount.push(function() {
    if (config === void 0 && !("config" in $$props || $$self.$$.bound[$$self.$$.props["config"]])) {
      console.warn("<Wedge> was created without expected prop 'config'");
    }
  });
  const writable_props = ["config", "handle", "staticConfig"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Wedge> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("config" in $$props2)
      $$invalidate(1, config = $$props2.config);
    if ("handle" in $$props2)
      $$invalidate(2, handle = $$props2.handle);
    if ("staticConfig" in $$props2)
      $$invalidate(3, staticConfig = $$props2.staticConfig);
  };
  $$self.$capture_state = () => ({
    Konva: import_konva21.default,
    onMount,
    onDestroy,
    createEventDispatcher,
    registerEvents,
    getParentContainer,
    copyExistingKeys,
    config,
    handle,
    staticConfig,
    parent,
    dispatcher,
    $parent
  });
  $$self.$inject_state = ($$props2) => {
    if ("config" in $$props2)
      $$invalidate(1, config = $$props2.config);
    if ("handle" in $$props2)
      $$invalidate(2, handle = $$props2.handle);
    if ("staticConfig" in $$props2)
      $$invalidate(3, staticConfig = $$props2.staticConfig);
    if ("parent" in $$props2)
      $$invalidate(0, parent = $$props2.parent);
    if ("dispatcher" in $$props2)
      dispatcher = $$props2.dispatcher;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*handle, config*/
    6) {
      $:
        handle.setAttrs(config);
    }
  };
  return [parent, config, handle, staticConfig];
}
var Wedge = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance21, create_fragment21, safe_not_equal, { config: 1, handle: 2, staticConfig: 3 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Wedge",
      options,
      id: create_fragment21.name
    });
  }
  get config() {
    throw new Error("<Wedge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set config(value) {
    throw new Error("<Wedge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get handle() {
    throw new Error("<Wedge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set handle(value) {
    throw new Error("<Wedge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get staticConfig() {
    throw new Error("<Wedge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set staticConfig(value) {
    throw new Error("<Wedge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Wedge_default = Wedge;

// node_modules/svelte-konva/dist/Tag.svelte
var import_konva22 = __toESM(require_lib());
function create_fragment22(ctx) {
  const block = {
    c: noop,
    l: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment22.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance22($$self, $$props, $$invalidate) {
  let $parent;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Tag", slots, []);
  let { config } = $$props;
  let { handle = new import_konva22.default.Tag(config) } = $$props;
  let { staticConfig = false } = $$props;
  let parent = getParentContainer();
  validate_store(parent, "parent");
  component_subscribe($$self, parent, (value) => $$invalidate(4, $parent = value));
  let dispatcher = createEventDispatcher();
  onMount(() => {
    $parent.add(handle);
    if (!staticConfig) {
      handle.on("transformend", () => {
        copyExistingKeys(config, handle.getAttrs());
        $$invalidate(1, config);
      });
      handle.on("dragend", () => {
        copyExistingKeys(config, handle.getAttrs());
        $$invalidate(1, config);
      });
    }
    registerEvents(dispatcher, handle);
  });
  onDestroy(() => {
    handle.destroy();
  });
  $$self.$$.on_mount.push(function() {
    if (config === void 0 && !("config" in $$props || $$self.$$.bound[$$self.$$.props["config"]])) {
      console.warn("<Tag> was created without expected prop 'config'");
    }
  });
  const writable_props = ["config", "handle", "staticConfig"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Tag> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("config" in $$props2)
      $$invalidate(1, config = $$props2.config);
    if ("handle" in $$props2)
      $$invalidate(2, handle = $$props2.handle);
    if ("staticConfig" in $$props2)
      $$invalidate(3, staticConfig = $$props2.staticConfig);
  };
  $$self.$capture_state = () => ({
    Konva: import_konva22.default,
    onMount,
    onDestroy,
    createEventDispatcher,
    registerEvents,
    getParentContainer,
    copyExistingKeys,
    config,
    handle,
    staticConfig,
    parent,
    dispatcher,
    $parent
  });
  $$self.$inject_state = ($$props2) => {
    if ("config" in $$props2)
      $$invalidate(1, config = $$props2.config);
    if ("handle" in $$props2)
      $$invalidate(2, handle = $$props2.handle);
    if ("staticConfig" in $$props2)
      $$invalidate(3, staticConfig = $$props2.staticConfig);
    if ("parent" in $$props2)
      $$invalidate(0, parent = $$props2.parent);
    if ("dispatcher" in $$props2)
      dispatcher = $$props2.dispatcher;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*handle, config*/
    6) {
      $:
        handle.setAttrs(config);
    }
  };
  return [parent, config, handle, staticConfig];
}
var Tag = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance22, create_fragment22, safe_not_equal, { config: 1, handle: 2, staticConfig: 3 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Tag",
      options,
      id: create_fragment22.name
    });
  }
  get config() {
    throw new Error("<Tag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set config(value) {
    throw new Error("<Tag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get handle() {
    throw new Error("<Tag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set handle(value) {
    throw new Error("<Tag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get staticConfig() {
    throw new Error("<Tag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set staticConfig(value) {
    throw new Error("<Tag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Tag_default = Tag;
export {
  Arc_default as Arc,
  Arrow_default as Arrow,
  Circle_default as Circle,
  Ellipse_default as Ellipse,
  Group_default as Group,
  Image_default as Image,
  Label_default as Label,
  Layer_default as Layer,
  Line_default as Line,
  Path_default as Path,
  Rect_default as Rect,
  RegularPolygon_default as RegularPolygon,
  Ring_default as Ring,
  Shape_default as Shape,
  Sprite_default as Sprite,
  Stage_default as Stage,
  Star_default as Star,
  Tag_default as Tag,
  Text_default as Text,
  TextPath_default as TextPath,
  Transformer_default as Transformer,
  Wedge_default as Wedge
};
//# sourceMappingURL=svelte-konva.js.map
